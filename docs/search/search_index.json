{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GraphQL with bareASGI \u00b6 GraphQL support for bareASGI . Endpoints are provided for: graphql queries, mutations and subscriptions, A graphiql app (browse to /graphiql). Note this uses the graphql-core-next GraphQL implementation. There is also optional support for graphene , using a temporary fork which adds subscription support.","title":"GraphQL with bareASGI"},{"location":"#graphql-with-bareasgi","text":"GraphQL support for bareASGI . Endpoints are provided for: graphql queries, mutations and subscriptions, A graphiql app (browse to /graphiql). Note this uses the graphql-core-next GraphQL implementation. There is also optional support for graphene , using a temporary fork which adds subscription support.","title":"GraphQL with bareASGI"},{"location":"api/bareasgi_graphene/","text":"function bareasgi_graphql_next.graphene . add_graphene \u00b6 Summary \u00b6 Add graphql support to an bareASGI application. bareasgi_graphql_next.graphene . add_graphene ( app : Application , schema : Schema , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] , graphql_middleware : [type] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None Parameters \u00b6 app : Application The bareASGI application. schema : Schema The Graphene schema to use. path_prefix : str (optional) An optional path prefix from which to provide endpoints. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the rest end points. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the GraphiQL end point. Defaults to None. graphql_middleware : [type] (optional) Middleware for graphql-core-next. Defaults to None. ping_interval : float (optional) The time to wait before abandoning an unused subscription. Defaults to 10. loads : Callable[[str], Any] (optional) The function to convert a JSON string to an object. Defaults to json.loads. dumps : Callable[[Any], str] (optional) The function to convert an object to a JSON string. Defaults to json.dumps. class GrapheneController ( GraphQLControllerBase ) \u00b6 Summary \u00b6 Create a Graphene controller bareasgi_graphql_next.graphene . GrapheneController ( schema : graphene.Schema , path_prefix : str , middleware : Optional[Union[Tuple, List, MiddlewareManager] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None Parameters \u00b6 schema : graphene.Schema The Graphene schema path_prefix : str The path prefix. middleware : Optional[Union[Tuple, List, MiddlewareManager] The middleware. Defaults to None. ping_interval : float The WebSocket ping interval. loads : Callable[[str], Any] The function to convert a JSON string to an object. dumps : Callable[[Any], str] The function to convert an object to a JSON string. Defaults to json.dumps. method GrapheneController . add_routes \u00b6 Summary \u00b6 Add the routes GrapheneController . add_routes ( app : Application , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] ) -> Any Parameters \u00b6 app : Application The ASGI application path_prefix : str (optional) The path prefix. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) The rest middleware. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) The view middleware. Defaults to None. Returns \u00b6 Any : async method GrapheneController . handle_graphql \u00b6 Summary \u00b6 A request handler for graphql queries async GrapheneController . handle_graphql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : The HTTP response to the query request async method GrapheneController . handle_sse_get \u00b6 Summary \u00b6 Handle a server sent event style direct subscription async GrapheneController . handle_sse_get ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : The streaming response async method GrapheneController . handle_sse_post \u00b6 Summary \u00b6 Handle a server sent event style direct subscription async GrapheneController . handle_sse_post ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : A stream response async method GrapheneController . handle_websocket_subscription \u00b6 Summary \u00b6 Handle a websocket subscription async GrapheneController . handle_websocket_subscription ( scope : Scope , info : Info , matches : RouteMatches , web_socket : WebSocket ) -> None Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info matches : RouteMatches The route matches web_socket : WebSocket The web socket to interact with async method GrapheneController . query \u00b6 Summary \u00b6 Execute a query async GrapheneController . query ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> ExecutionResult Parameters \u00b6 query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info. Returns \u00b6 ExecutionResult : The query results. async method GrapheneController . shutdown \u00b6 Summary \u00b6 Shutdown the service async GrapheneController . shutdown ( ) -> None async method GrapheneController . subscribe \u00b6 Summary \u00b6 Execute a subscription. async GrapheneController . subscribe ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> MapAsyncIterator Parameters \u00b6 query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info. Returns \u00b6 MapAsyncIterator : An asynchronous iterator of the results. async method GrapheneController . view_graphiql \u00b6 Summary \u00b6 Render the Graphiql view async GrapheneController . view_graphiql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The user info matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : [description]","title":"bareasgi_graphene"},{"location":"api/bareasgi_graphene/#function-bareasgi_graphql_nextgrapheneadd_graphene","text":"","title":"function bareasgi_graphql_next.graphene.add_graphene"},{"location":"api/bareasgi_graphene/#summary","text":"Add graphql support to an bareASGI application. bareasgi_graphql_next.graphene . add_graphene ( app : Application , schema : Schema , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] , graphql_middleware : [type] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters","text":"app : Application The bareASGI application. schema : Schema The Graphene schema to use. path_prefix : str (optional) An optional path prefix from which to provide endpoints. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the rest end points. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the GraphiQL end point. Defaults to None. graphql_middleware : [type] (optional) Middleware for graphql-core-next. Defaults to None. ping_interval : float (optional) The time to wait before abandoning an unused subscription. Defaults to 10. loads : Callable[[str], Any] (optional) The function to convert a JSON string to an object. Defaults to json.loads. dumps : Callable[[Any], str] (optional) The function to convert an object to a JSON string. Defaults to json.dumps.","title":"Parameters"},{"location":"api/bareasgi_graphene/#class-graphenecontrollergraphqlcontrollerbase","text":"","title":"class GrapheneController(GraphQLControllerBase)"},{"location":"api/bareasgi_graphene/#summary_1","text":"Create a Graphene controller bareasgi_graphql_next.graphene . GrapheneController ( schema : graphene.Schema , path_prefix : str , middleware : Optional[Union[Tuple, List, MiddlewareManager] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_1","text":"schema : graphene.Schema The Graphene schema path_prefix : str The path prefix. middleware : Optional[Union[Tuple, List, MiddlewareManager] The middleware. Defaults to None. ping_interval : float The WebSocket ping interval. loads : Callable[[str], Any] The function to convert a JSON string to an object. dumps : Callable[[Any], str] The function to convert an object to a JSON string. Defaults to json.dumps.","title":"Parameters"},{"location":"api/bareasgi_graphene/#method-graphenecontrolleradd_routes","text":"","title":"method GrapheneController.add_routes"},{"location":"api/bareasgi_graphene/#summary_2","text":"Add the routes GrapheneController . add_routes ( app : Application , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] ) -> Any","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_2","text":"app : Application The ASGI application path_prefix : str (optional) The path prefix. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) The rest middleware. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) The view middleware. Defaults to None.","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns","text":"Any :","title":"Returns"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollerhandle_graphql","text":"","title":"async method GrapheneController.handle_graphql"},{"location":"api/bareasgi_graphene/#summary_3","text":"A request handler for graphql queries async GrapheneController . handle_graphql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_3","text":"scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns_1","text":"HttpResponse : The HTTP response to the query request","title":"Returns"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollerhandle_sse_get","text":"","title":"async method GrapheneController.handle_sse_get"},{"location":"api/bareasgi_graphene/#summary_4","text":"Handle a server sent event style direct subscription async GrapheneController . handle_sse_get ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_4","text":"scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns_2","text":"HttpResponse : The streaming response","title":"Returns"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollerhandle_sse_post","text":"","title":"async method GrapheneController.handle_sse_post"},{"location":"api/bareasgi_graphene/#summary_5","text":"Handle a server sent event style direct subscription async GrapheneController . handle_sse_post ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_5","text":"scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns_3","text":"HttpResponse : A stream response","title":"Returns"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollerhandle_websocket_subscription","text":"","title":"async method GrapheneController.handle_websocket_subscription"},{"location":"api/bareasgi_graphene/#summary_6","text":"Handle a websocket subscription async GrapheneController . handle_websocket_subscription ( scope : Scope , info : Info , matches : RouteMatches , web_socket : WebSocket ) -> None","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_6","text":"scope : Scope The ASGI scope info : Info The application info matches : RouteMatches The route matches web_socket : WebSocket The web socket to interact with","title":"Parameters"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollerquery","text":"","title":"async method GrapheneController.query"},{"location":"api/bareasgi_graphene/#summary_7","text":"Execute a query async GrapheneController . query ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> ExecutionResult","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_7","text":"query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info.","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns_4","text":"ExecutionResult : The query results.","title":"Returns"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollershutdown","text":"","title":"async method GrapheneController.shutdown"},{"location":"api/bareasgi_graphene/#summary_8","text":"Shutdown the service async GrapheneController . shutdown ( ) -> None","title":"Summary"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollersubscribe","text":"","title":"async method GrapheneController.subscribe"},{"location":"api/bareasgi_graphene/#summary_9","text":"Execute a subscription. async GrapheneController . subscribe ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> MapAsyncIterator","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_8","text":"query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info.","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns_5","text":"MapAsyncIterator : An asynchronous iterator of the results.","title":"Returns"},{"location":"api/bareasgi_graphene/#async-method-graphenecontrollerview_graphiql","text":"","title":"async method GrapheneController.view_graphiql"},{"location":"api/bareasgi_graphene/#summary_10","text":"Render the Graphiql view async GrapheneController . view_graphiql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphene/#parameters_9","text":"scope : Scope The ASGI scope info : Info The user info matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphene/#returns_6","text":"HttpResponse : [description]","title":"Returns"},{"location":"api/bareasgi_graphql_next/","text":"function bareasgi_graphql_next.graphql . add_graphql_next \u00b6 Summary \u00b6 Add graphql support to an bareASGI application. bareasgi_graphql_next.graphql . add_graphql_next ( app : Application , schema : GraphQLSchema , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] , graphql_middleware : [type] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None Parameters \u00b6 app : Application The bareASGI application. schema : GraphQLSchema The GraphQL schema to use. path_prefix : str (optional) An optional path prefix from which to provide endpoints. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the rest end points. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the GraphiQL end point. Defaults to None. graphql_middleware : [type] (optional) Middleware for graphql-core-next. Defaults to None. ping_interval : float (optional) The time to wait before abandoning an unused subscription. Defaults to 10. loads : Callable[[str], Any] (optional) The function to convert a JSON string to an object. Defaults to json.loads. dumps : Callable[[Any], str] (optional) The function to convert an object to a JSON string. Defaults to json.dumps. class GraphQLController ( GraphQLControllerBase ) \u00b6 Summary \u00b6 Create a GraphQL controller bareasgi_graphql_next.graphql . GraphQLController ( schema : GraphQLSchema , path_prefix : str , middleware : Optional[Union[Tuple, List, MiddlewareManager] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None Parameters \u00b6 schema : GraphQLSchema The Graphql schema path_prefix : str The path prefix. middleware : Optional[Union[Tuple, List, MiddlewareManager] The middleware. Defaults to None. ping_interval : float The WebSocket ping interval. loads : Callable[[str], Any] The function to convert a JSON string to an object. dumps : Callable[[Any], str] The function to convert an object to a JSON string. method GraphQLController . add_routes \u00b6 Summary \u00b6 Add the routes GraphQLController . add_routes ( app : Application , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] ) -> Any Parameters \u00b6 app : Application The ASGI application path_prefix : str (optional) The path prefix. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) The rest middleware. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) The view middleware. Defaults to None. Returns \u00b6 Any : async method GraphQLController . handle_graphql \u00b6 Summary \u00b6 A request handler for graphql queries async GraphQLController . handle_graphql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : The HTTP response to the query request async method GraphQLController . handle_sse_get \u00b6 Summary \u00b6 Handle a server sent event style direct subscription async GraphQLController . handle_sse_get ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : The streaming response async method GraphQLController . handle_sse_post \u00b6 Summary \u00b6 Handle a server sent event style direct subscription async GraphQLController . handle_sse_post ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : A stream response async method GraphQLController . handle_websocket_subscription \u00b6 Summary \u00b6 Handle a websocket subscription async GraphQLController . handle_websocket_subscription ( scope : Scope , info : Info , matches : RouteMatches , web_socket : WebSocket ) -> None Parameters \u00b6 scope : Scope The ASGI scope info : Info The application info matches : RouteMatches The route matches web_socket : WebSocket The web socket to interact with async method GraphQLController . query \u00b6 Summary \u00b6 Execute a query async GraphQLController . query ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> ExecutionResult Parameters \u00b6 query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info. Returns \u00b6 ExecutionResult : The query results. async method GraphQLController . shutdown \u00b6 Summary \u00b6 Shutdown the service async GraphQLController . shutdown ( ) -> None async method GraphQLController . subscribe \u00b6 Summary \u00b6 Execute a subscription. async GraphQLController . subscribe ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> MapAsyncIterator Parameters \u00b6 query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info. Returns \u00b6 MapAsyncIterator : An asynchronous iterator of the results. async method GraphQLController . view_graphiql \u00b6 Summary \u00b6 Render the Graphiql view async GraphQLController . view_graphiql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse Parameters \u00b6 scope : Scope The ASGI scope info : Info The user info matches : RouteMatches The route matches content : Content The request body Returns \u00b6 HttpResponse : [description]","title":"bareasgi_graphql_next"},{"location":"api/bareasgi_graphql_next/#function-bareasgi_graphql_nextgraphqladd_graphql_next","text":"","title":"function bareasgi_graphql_next.graphql.add_graphql_next"},{"location":"api/bareasgi_graphql_next/#summary","text":"Add graphql support to an bareASGI application. bareasgi_graphql_next.graphql . add_graphql_next ( app : Application , schema : GraphQLSchema , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] , graphql_middleware : [type] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters","text":"app : Application The bareASGI application. schema : GraphQLSchema The GraphQL schema to use. path_prefix : str (optional) An optional path prefix from which to provide endpoints. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the rest end points. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) Middleware for the GraphiQL end point. Defaults to None. graphql_middleware : [type] (optional) Middleware for graphql-core-next. Defaults to None. ping_interval : float (optional) The time to wait before abandoning an unused subscription. Defaults to 10. loads : Callable[[str], Any] (optional) The function to convert a JSON string to an object. Defaults to json.loads. dumps : Callable[[Any], str] (optional) The function to convert an object to a JSON string. Defaults to json.dumps.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#class-graphqlcontrollergraphqlcontrollerbase","text":"","title":"class GraphQLController(GraphQLControllerBase)"},{"location":"api/bareasgi_graphql_next/#summary_1","text":"Create a GraphQL controller bareasgi_graphql_next.graphql . GraphQLController ( schema : GraphQLSchema , path_prefix : str , middleware : Optional[Union[Tuple, List, MiddlewareManager] , ping_interval : float , loads : Callable[[str], Any] , dumps : Callable[[Any], str] ) -> None","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_1","text":"schema : GraphQLSchema The Graphql schema path_prefix : str The path prefix. middleware : Optional[Union[Tuple, List, MiddlewareManager] The middleware. Defaults to None. ping_interval : float The WebSocket ping interval. loads : Callable[[str], Any] The function to convert a JSON string to an object. dumps : Callable[[Any], str] The function to convert an object to a JSON string.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#method-graphqlcontrolleradd_routes","text":"","title":"method GraphQLController.add_routes"},{"location":"api/bareasgi_graphql_next/#summary_2","text":"Add the routes GraphQLController . add_routes ( app : Application , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] ) -> Any","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_2","text":"app : Application The ASGI application path_prefix : str (optional) The path prefix. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] (optional) The rest middleware. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] (optional) The view middleware. Defaults to None.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns","text":"Any :","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_graphql","text":"","title":"async method GraphQLController.handle_graphql"},{"location":"api/bareasgi_graphql_next/#summary_3","text":"A request handler for graphql queries async GraphQLController . handle_graphql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_3","text":"scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_1","text":"HttpResponse : The HTTP response to the query request","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_sse_get","text":"","title":"async method GraphQLController.handle_sse_get"},{"location":"api/bareasgi_graphql_next/#summary_4","text":"Handle a server sent event style direct subscription async GraphQLController . handle_sse_get ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_4","text":"scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_2","text":"HttpResponse : The streaming response","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_sse_post","text":"","title":"async method GraphQLController.handle_sse_post"},{"location":"api/bareasgi_graphql_next/#summary_5","text":"Handle a server sent event style direct subscription async GraphQLController . handle_sse_post ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_5","text":"scope : Scope The ASGI scope info : Info The application info object matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_3","text":"HttpResponse : A stream response","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_websocket_subscription","text":"","title":"async method GraphQLController.handle_websocket_subscription"},{"location":"api/bareasgi_graphql_next/#summary_6","text":"Handle a websocket subscription async GraphQLController . handle_websocket_subscription ( scope : Scope , info : Info , matches : RouteMatches , web_socket : WebSocket ) -> None","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_6","text":"scope : Scope The ASGI scope info : Info The application info matches : RouteMatches The route matches web_socket : WebSocket The web socket to interact with","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerquery","text":"","title":"async method GraphQLController.query"},{"location":"api/bareasgi_graphql_next/#summary_7","text":"Execute a query async GraphQLController . query ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> ExecutionResult","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_7","text":"query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_4","text":"ExecutionResult : The query results.","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollershutdown","text":"","title":"async method GraphQLController.shutdown"},{"location":"api/bareasgi_graphql_next/#summary_8","text":"Shutdown the service async GraphQLController . shutdown ( ) -> None","title":"Summary"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollersubscribe","text":"","title":"async method GraphQLController.subscribe"},{"location":"api/bareasgi_graphql_next/#summary_9","text":"Execute a subscription. async GraphQLController . subscribe ( query : str , variables : Optional[Dict[str, Any]] , operation_name : Optional[str] , scope : Scope , info : Info ) -> MapAsyncIterator","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_8","text":"query : str The subscription query. variables : Optional[Dict[str, Any]] Optional variables. operation_name : Optional[str] An optional operation name. scope : Scope The ASGI scope. info : Info The application info.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_5","text":"MapAsyncIterator : An asynchronous iterator of the results.","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerview_graphiql","text":"","title":"async method GraphQLController.view_graphiql"},{"location":"api/bareasgi_graphql_next/#summary_10","text":"Render the Graphiql view async GraphQLController . view_graphiql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_9","text":"scope : Scope The ASGI scope info : Info The user info matches : RouteMatches The route matches content : Content The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_6","text":"HttpResponse : [description]","title":"Returns"},{"location":"user-guide/clients/","text":"Clients \u00b6 Overview \u00b6 GraphQL supports three types of actions : Queries Mutations Subscriptions Queries & Mutations \u00b6 The controller exposes an endpoint /graphql . There are a number of libraries that can be used including Facebook Relay and Apollo GraphQL . These are feature rich, but the underlying mechanism for queries and mutations is just a simple fetch request. Here is a code snippet demonstrating a query. const query = 'query { myQuery { someField otherField } }' const variables = null const operationName = null const url = 'http://www.exammple.com/graphql' // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => response . json ()) . then ( data => console . log ( data ) . catch ( error => console . log ( error )) We might wrap this up in the following function: export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onError , onSuccess ) { // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . ok ) { response . json () . then ( json => { onSuccess ( json ) }) . catch ( error => onError ( error )) } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) } This can then be called like this: const url = 'http://www.example.com/graphql' const query = 'query { someQuery { someField someOtherField } }' const variables = null const operationName = null graphQLClient ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data )) Subscriptions \u00b6 Two transport mechanisms are provided for GraphQL subscriptions: WebSockets Server Sent Events WebSockets \u00b6 Subscriptions can be made over WebSockets implementing the Apollo GraphQL transport protocol using the /subscriptions endpoint. This seems to be the most widely used mechanism and is compatible with the majority of javascript front libraries. The implementation of the JavaScript WebSocket client is too complex to describe here, but there is an implementation in @jetblack/graphql-client , the implementation of which is discussed here . This is the protocol used by the inbuilt GraphiQL IDE . Server Sent Events \u00b6 As well as the more popular WebSocket Subscription, a mechanism using server sent events is also supported. While this is uncommon, it is a really good use of SSE, as all the communication if from the server to the client. The GraphQL controller exposes an endpoint: /sse-subscription?query=...&variables=...&operationName=... This can be called in the following manner: const query = encodeURIComponent ( 'subscription { mySubscription { name timestamp } }' ) const url = `http://www.example.com/sse-subscription?query= ${ query } ` const eventSource = new EventSource ( url ) eventSource . onmessage = event => { data = JSON . parse ( event . data ) console . log ( data ) } We could wrap this up in the following manner: export function graphQLSubscriber ( url , query , variables , operationName , onError , onSuccess ) { let subscriptionUrl = url + '?query=' + encodeURIComponent ( query ) if ( variables ) { subscriptionUrl += '&variables=' + encodeURIComponent ( JSON . stringify ( variables )) } if ( operationName ) { subscriptionUrl += '&operationName=' + encodeURIComponent ( operationName ) } const eventSource = new EventSource ( subscriptionUrl ) eventSource . onmessage = event => onSuccess ( JSON . parse ( event . data )) eventSource . onerror = error => onError ( error ) // Return the close function to unsubscribe. return eventSource . close } This can then be called like this: const url = 'http://www.example.com/sse-subscription' const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null graphQLSubscriber ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data )) Queries, Mutations & Subscriptions \u00b6 In this implementation queries, mutations and subscriptions can all be made using the fetch api. With a successful query or mutation the response status code is 200 (OK), and the body contains the result. For a subscription the status code 201 (CREATED) is returned, and the location header contains the url to be used to request server sent events through the EventSource API. This means we can provide a single client function to handle all three requests. Here is some sample code that does this. export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onNext , onError , onComplete ) { const abortController = new AbortController () // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { onNext ( json ) onComplete () }) . catch ( error => onError ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { const data = JSON . parse ( event . data ) onNext ( data ) } eventSource . onerror = error => { onError ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) // Return an unsubscribe function. return () => { abortController . abort () } } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const unsubscribe = graphQLClient ( url , query , variables , operationName , data => console . log ( data ), error => console . log ( error ), () => console . log ( 'complete' )) // Later ... unsubscribe () Observable \u00b6 Clearly the above code roles it's own observable pattern. We can wrap this up with rxjs to provide a cleaner client. import { Observable } from 'rxjs' export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function observableGraphQL ( url , query , variables , operationName ) { return Observable . create ( observer => { const abortController = new AbortController () fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { observer . next ( json ) observer . complete () }) . catch ( error => observer . error ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { observer . next ( JSON . parse ( event . data )) } eventSource . onerror = error => { observer . error ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { observer . error ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => observer . error ( error )) // Return the unsubscribe function. return () => { abortController . abort () } }) } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const subscription = observableGraphQL ( url , query , variables , operationName ) . subscribe ({ next : responses => console . log ( response ), error : error => console . log ( error ), complete : () => console . log ( 'complete' ) }) // Later ... subscription . unsubscribe () Prebuilt Clients \u00b6 There are some prebuilt javascript clients: barejs-graphql-client for callback style clients. barejs-graphql-observable for observable style clients using rxjs .","title":"Clients"},{"location":"user-guide/clients/#clients","text":"","title":"Clients"},{"location":"user-guide/clients/#overview","text":"GraphQL supports three types of actions : Queries Mutations Subscriptions","title":"Overview"},{"location":"user-guide/clients/#queries-mutations","text":"The controller exposes an endpoint /graphql . There are a number of libraries that can be used including Facebook Relay and Apollo GraphQL . These are feature rich, but the underlying mechanism for queries and mutations is just a simple fetch request. Here is a code snippet demonstrating a query. const query = 'query { myQuery { someField otherField } }' const variables = null const operationName = null const url = 'http://www.exammple.com/graphql' // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => response . json ()) . then ( data => console . log ( data ) . catch ( error => console . log ( error )) We might wrap this up in the following function: export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onError , onSuccess ) { // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . ok ) { response . json () . then ( json => { onSuccess ( json ) }) . catch ( error => onError ( error )) } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) } This can then be called like this: const url = 'http://www.example.com/graphql' const query = 'query { someQuery { someField someOtherField } }' const variables = null const operationName = null graphQLClient ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data ))","title":"Queries &amp; Mutations"},{"location":"user-guide/clients/#subscriptions","text":"Two transport mechanisms are provided for GraphQL subscriptions: WebSockets Server Sent Events","title":"Subscriptions"},{"location":"user-guide/clients/#websockets","text":"Subscriptions can be made over WebSockets implementing the Apollo GraphQL transport protocol using the /subscriptions endpoint. This seems to be the most widely used mechanism and is compatible with the majority of javascript front libraries. The implementation of the JavaScript WebSocket client is too complex to describe here, but there is an implementation in @jetblack/graphql-client , the implementation of which is discussed here . This is the protocol used by the inbuilt GraphiQL IDE .","title":"WebSockets"},{"location":"user-guide/clients/#server-sent-events","text":"As well as the more popular WebSocket Subscription, a mechanism using server sent events is also supported. While this is uncommon, it is a really good use of SSE, as all the communication if from the server to the client. The GraphQL controller exposes an endpoint: /sse-subscription?query=...&variables=...&operationName=... This can be called in the following manner: const query = encodeURIComponent ( 'subscription { mySubscription { name timestamp } }' ) const url = `http://www.example.com/sse-subscription?query= ${ query } ` const eventSource = new EventSource ( url ) eventSource . onmessage = event => { data = JSON . parse ( event . data ) console . log ( data ) } We could wrap this up in the following manner: export function graphQLSubscriber ( url , query , variables , operationName , onError , onSuccess ) { let subscriptionUrl = url + '?query=' + encodeURIComponent ( query ) if ( variables ) { subscriptionUrl += '&variables=' + encodeURIComponent ( JSON . stringify ( variables )) } if ( operationName ) { subscriptionUrl += '&operationName=' + encodeURIComponent ( operationName ) } const eventSource = new EventSource ( subscriptionUrl ) eventSource . onmessage = event => onSuccess ( JSON . parse ( event . data )) eventSource . onerror = error => onError ( error ) // Return the close function to unsubscribe. return eventSource . close } This can then be called like this: const url = 'http://www.example.com/sse-subscription' const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null graphQLSubscriber ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data ))","title":"Server Sent Events"},{"location":"user-guide/clients/#queries-mutations-subscriptions","text":"In this implementation queries, mutations and subscriptions can all be made using the fetch api. With a successful query or mutation the response status code is 200 (OK), and the body contains the result. For a subscription the status code 201 (CREATED) is returned, and the location header contains the url to be used to request server sent events through the EventSource API. This means we can provide a single client function to handle all three requests. Here is some sample code that does this. export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onNext , onError , onComplete ) { const abortController = new AbortController () // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { onNext ( json ) onComplete () }) . catch ( error => onError ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { const data = JSON . parse ( event . data ) onNext ( data ) } eventSource . onerror = error => { onError ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) // Return an unsubscribe function. return () => { abortController . abort () } } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const unsubscribe = graphQLClient ( url , query , variables , operationName , data => console . log ( data ), error => console . log ( error ), () => console . log ( 'complete' )) // Later ... unsubscribe ()","title":"Queries, Mutations &amp; Subscriptions"},{"location":"user-guide/clients/#observable","text":"Clearly the above code roles it's own observable pattern. We can wrap this up with rxjs to provide a cleaner client. import { Observable } from 'rxjs' export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function observableGraphQL ( url , query , variables , operationName ) { return Observable . create ( observer => { const abortController = new AbortController () fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { observer . next ( json ) observer . complete () }) . catch ( error => observer . error ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { observer . next ( JSON . parse ( event . data )) } eventSource . onerror = error => { observer . error ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { observer . error ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => observer . error ( error )) // Return the unsubscribe function. return () => { abortController . abort () } }) } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const subscription = observableGraphQL ( url , query , variables , operationName ) . subscribe ({ next : responses => console . log ( response ), error : error => console . log ( error ), complete : () => console . log ( 'complete' ) }) // Later ... subscription . unsubscribe ()","title":"Observable"},{"location":"user-guide/clients/#prebuilt-clients","text":"There are some prebuilt javascript clients: barejs-graphql-client for callback style clients. barejs-graphql-observable for observable style clients using rxjs .","title":"Prebuilt Clients"},{"location":"user-guide/getting-started/","text":"Getting Started \u00b6 A utility function add_graphql_next is provided. from bareasgi import Application from bareasgi_graphql_next import add_graphql_next from star_wars.star_wars_schema import star_wars_schema import uvicorn app = Application () add_graphql_next ( app , star_wars_schema ) uvicorn . run ( app , port = 9009 ) For graphene the utility function add_graphene is provided. import asyncio from datetime import datetime from bareasgi import Application from bareasgi_graphql_next.graphene import add_graphene from graphene import ObjectType , String , Schema , Field import uvicorn # All schema require a query. class Query ( ObjectType ): hello = String () def resolve_hello ( root , info ): return 'Hello, world!' class Subscription ( ObjectType ): time = Field ( String ) async def subscribe_time ( root , info ): while True : yield { 'time' : datetime . now () . isoformat ()} await asyncio . sleep ( 1 ) SCHEMA = Schema ( query = Query , subscription = Subscription ) app = Application () add_graphene ( app , SCHEMA ) uvicorn . run ( app , port = 9009 )","title":"Getting Started"},{"location":"user-guide/getting-started/#getting-started","text":"A utility function add_graphql_next is provided. from bareasgi import Application from bareasgi_graphql_next import add_graphql_next from star_wars.star_wars_schema import star_wars_schema import uvicorn app = Application () add_graphql_next ( app , star_wars_schema ) uvicorn . run ( app , port = 9009 ) For graphene the utility function add_graphene is provided. import asyncio from datetime import datetime from bareasgi import Application from bareasgi_graphql_next.graphene import add_graphene from graphene import ObjectType , String , Schema , Field import uvicorn # All schema require a query. class Query ( ObjectType ): hello = String () def resolve_hello ( root , info ): return 'Hello, world!' class Subscription ( ObjectType ): time = Field ( String ) async def subscribe_time ( root , info ): while True : yield { 'time' : datetime . now () . isoformat ()} await asyncio . sleep ( 1 ) SCHEMA = Schema ( query = Query , subscription = Subscription ) app = Application () add_graphene ( app , SCHEMA ) uvicorn . run ( app , port = 9009 )","title":"Getting Started"},{"location":"user-guide/installation/","text":"Installation \u00b6 The package can be installed with pip. pip install bareasgi-graphql-next This is a Python 3.7 and later package with dependencies on: bareASGI graphql-core-next There is optional support for graphene: pip install bareasgi-graphql-next [ graphene ] This adds a dependency on a forked version of graphene which supports subscriptions.","title":"Installation"},{"location":"user-guide/installation/#installation","text":"The package can be installed with pip. pip install bareasgi-graphql-next This is a Python 3.7 and later package with dependencies on: bareASGI graphql-core-next There is optional support for graphene: pip install bareasgi-graphql-next [ graphene ] This adds a dependency on a forked version of graphene which supports subscriptions.","title":"Installation"}]}