{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GraphQL with bareASGI \u00b6 GraphQL support for bareASGI <https://bareasgi.readthedocs.io/en/latest> _. Endpoints are provided for: graphql queries, mutations and subscriptions, A graphiql app (browse to /graphiql). Note this uses the graphql-core-next <https://github.com/graphql-python/graphql-core-next> _ GraphQL implementation.","title":"GraphQL with bareASGI"},{"location":"#graphql-with-bareasgi","text":"GraphQL support for bareASGI <https://bareasgi.readthedocs.io/en/latest> _. Endpoints are provided for: graphql queries, mutations and subscriptions, A graphiql app (browse to /graphiql). Note this uses the graphql-core-next <https://github.com/graphql-python/graphql-core-next> _ GraphQL implementation.","title":"GraphQL with bareASGI"},{"location":"api/bareasgi_graphql_next/","text":"API \u00b6 function bareasgi_graphql_next . add_graphql_next \u00b6 Summary \u00b6 Add graphql support to an bareASGI application. bareasgi_graphql_next . add_graphql_next ( app : Application , schema : GraphQLSchema , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] , graphql_middleware : [type] , ping_interval : float ) Parameters \u00b6 app : Application (optional) The bareASGI application. schema : GraphQLSchema (optional) The GraphQL schema to use. path_prefix : str An optional path prefix from which to provide endpoints. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] Middleware for the rest end points. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] Middleware for the GraphiQL end point. Defaults to None. graphql_middleware : [type] Middleware for graphql-core-next. Defaults to None. ping_interval : float The time to wait before abandoning an unused subscription. Defaults to 10. Returns \u00b6 Any : class GraphQLController \u00b6 Summary \u00b6 Initialize self. See help(type(self)) for accurate signature. bareasgi_graphql_next . GraphQLController ( path_prefix : str , middleware : Any , ping_interval : float ) Parameters \u00b6 path_prefix : str middleware : Any ping_interval : float method GraphQLController . add_routes \u00b6 Summary \u00b6 Add the routes GraphQLController . add_routes ( app : Application , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] ) Parameters \u00b6 app : Application (optional) The ASGI application path_prefix : str The path prefix. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] The rest middleware. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] The view middleware. Defaults to None. Returns \u00b6 Any : async method GraphQLController . handle_graphql \u00b6 Summary \u00b6 A request handler for graphql queries async GraphQLController . handle_graphql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) Parameters \u00b6 scope : Scope (optional) The ASGI scope info : Info (optional) The application info object matches : RouteMatches (optional) The route matches content : Content (optional) The request body Returns \u00b6 HttpResponse : The HTTP response to the query request async method GraphQLController . handle_sse_get \u00b6 Summary \u00b6 Handle a server sent event style direct subscription async GraphQLController . handle_sse_get ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) Parameters \u00b6 scope : Scope (optional) The ASGI scope info : Info (optional) The application info object matches : RouteMatches (optional) The route matches content : Content (optional) The request body Returns \u00b6 HttpResponse : The streaming response async method GraphQLController . handle_sse_post \u00b6 Summary \u00b6 Handle a server sent event style direct subscription async GraphQLController . handle_sse_post ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) Parameters \u00b6 scope : Scope (optional) The ASGI scope info : Info (optional) The application info object matches : RouteMatches (optional) The route matches content : Content (optional) The request body Returns \u00b6 HttpResponse : A stream response async method GraphQLController . handle_subscription \u00b6 Summary \u00b6 Handle a websocket subscription async GraphQLController . handle_subscription ( scope : Scope , info : Info , matches : RouteMatches , web_socket : WebSocket ) Parameters \u00b6 scope : Scope (optional) The ASGI scope info : Info (optional) The application info matches : RouteMatches (optional) The route matches web_socket : WebSocket (optional) The web socket to interact with Returns \u00b6 Any : async method GraphQLController . shutdown \u00b6 Summary \u00b6 Shutdown the service async GraphQLController . shutdown ( ) Parameters \u00b6 Returns \u00b6 Any : async method GraphQLController . view_graphiql \u00b6 Summary \u00b6 Render the Graphiql view async GraphQLController . view_graphiql ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) Parameters \u00b6 scope : Scope (optional) The ASGI scope info : Info (optional) The user info matches : RouteMatches (optional) The route matches content : Content (optional) The request body Returns \u00b6 HttpResponse : [description]","title":"bareasgi_graphql_next"},{"location":"api/bareasgi_graphql_next/#api","text":"","title":"API"},{"location":"api/bareasgi_graphql_next/#function-bareasgi_graphql_nextadd_graphql_next","text":"","title":"function bareasgi_graphql_next.add_graphql_next"},{"location":"api/bareasgi_graphql_next/#summary","text":"Add graphql support to an bareASGI application. bareasgi_graphql_next . add_graphql_next ( app : Application , schema : GraphQLSchema , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] , graphql_middleware : [type] , ping_interval : float )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters","text":"app : Application (optional) The bareASGI application. schema : GraphQLSchema (optional) The GraphQL schema to use. path_prefix : str An optional path prefix from which to provide endpoints. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] Middleware for the rest end points. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] Middleware for the GraphiQL end point. Defaults to None. graphql_middleware : [type] Middleware for graphql-core-next. Defaults to None. ping_interval : float The time to wait before abandoning an unused subscription. Defaults to 10.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns","text":"Any :","title":"Returns"},{"location":"api/bareasgi_graphql_next/#class-graphqlcontroller","text":"","title":"class GraphQLController"},{"location":"api/bareasgi_graphql_next/#summary_1","text":"Initialize self. See help(type(self)) for accurate signature. bareasgi_graphql_next . GraphQLController ( path_prefix : str , middleware : Any , ping_interval : float )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_1","text":"path_prefix : str middleware : Any ping_interval : float","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#method-graphqlcontrolleradd_routes","text":"","title":"method GraphQLController.add_routes"},{"location":"api/bareasgi_graphql_next/#summary_2","text":"Add the routes GraphQLController . add_routes ( app : Application , path_prefix : str , rest_middleware : Optional[HttpMiddlewareCallback] , view_middleware : Optional[HttpMiddlewareCallback] )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_2","text":"app : Application (optional) The ASGI application path_prefix : str The path prefix. Defaults to ''. rest_middleware : Optional[HttpMiddlewareCallback] The rest middleware. Defaults to None. view_middleware : Optional[HttpMiddlewareCallback] The view middleware. Defaults to None.","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_1","text":"Any :","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_graphql","text":"","title":"async method GraphQLController.handle_graphql"},{"location":"api/bareasgi_graphql_next/#summary_3","text":"A request handler for graphql queries async GraphQLController . handle_graphql ( scope : Scope , info : Info , matches : RouteMatches , content : Content )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_3","text":"scope : Scope (optional) The ASGI scope info : Info (optional) The application info object matches : RouteMatches (optional) The route matches content : Content (optional) The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_2","text":"HttpResponse : The HTTP response to the query request","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_sse_get","text":"","title":"async method GraphQLController.handle_sse_get"},{"location":"api/bareasgi_graphql_next/#summary_4","text":"Handle a server sent event style direct subscription async GraphQLController . handle_sse_get ( scope : Scope , info : Info , matches : RouteMatches , content : Content )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_4","text":"scope : Scope (optional) The ASGI scope info : Info (optional) The application info object matches : RouteMatches (optional) The route matches content : Content (optional) The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_3","text":"HttpResponse : The streaming response","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_sse_post","text":"","title":"async method GraphQLController.handle_sse_post"},{"location":"api/bareasgi_graphql_next/#summary_5","text":"Handle a server sent event style direct subscription async GraphQLController . handle_sse_post ( scope : Scope , info : Info , matches : RouteMatches , content : Content )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_5","text":"scope : Scope (optional) The ASGI scope info : Info (optional) The application info object matches : RouteMatches (optional) The route matches content : Content (optional) The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_4","text":"HttpResponse : A stream response","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerhandle_subscription","text":"","title":"async method GraphQLController.handle_subscription"},{"location":"api/bareasgi_graphql_next/#summary_6","text":"Handle a websocket subscription async GraphQLController . handle_subscription ( scope : Scope , info : Info , matches : RouteMatches , web_socket : WebSocket )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_6","text":"scope : Scope (optional) The ASGI scope info : Info (optional) The application info matches : RouteMatches (optional) The route matches web_socket : WebSocket (optional) The web socket to interact with","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_5","text":"Any :","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollershutdown","text":"","title":"async method GraphQLController.shutdown"},{"location":"api/bareasgi_graphql_next/#summary_7","text":"Shutdown the service async GraphQLController . shutdown ( )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_7","text":"","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_6","text":"Any :","title":"Returns"},{"location":"api/bareasgi_graphql_next/#async-method-graphqlcontrollerview_graphiql","text":"","title":"async method GraphQLController.view_graphiql"},{"location":"api/bareasgi_graphql_next/#summary_8","text":"Render the Graphiql view async GraphQLController . view_graphiql ( scope : Scope , info : Info , matches : RouteMatches , content : Content )","title":"Summary"},{"location":"api/bareasgi_graphql_next/#parameters_8","text":"scope : Scope (optional) The ASGI scope info : Info (optional) The user info matches : RouteMatches (optional) The route matches content : Content (optional) The request body","title":"Parameters"},{"location":"api/bareasgi_graphql_next/#returns_7","text":"HttpResponse : [description]","title":"Returns"},{"location":"user-guide/clients/","text":"Clients \u00b6 Overview \u00b6 GraphQL supports three types of actions : Queries Mutations Subscriptions Queries & Mutations \u00b6 The controller exposes an endpoint /graphql . There are a number of libraries that can be used including Facebook Relay and Apollo GraphQL . These are feature rich, but the underlying mechanism for queries and mutations is just a simple fetch request. Here is a code snippet demonstrating a query. const query = 'query { myQuery { someField otherField } }' const variables = null const operationName = null const url = 'http://www.exammple.com/graphql' // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => response . json ()) . then ( data => console . log ( data ) . catch ( error => console . log ( error )) We might wrap this up in the following function: export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onError , onSuccess ) { // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . ok ) { response . json () . then ( json => { onSuccess ( json ) }) . catch ( error => onError ( error )) } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) } This can then be called like this: const url = 'http://www.example.com/graphql' const query = 'query { someQuery { someField someOtherField } }' const variables = null const operationName = null graphQLClient ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data )) Subscriptions \u00b6 Two transport mechanisms are provided for GraphQL subscriptions: WebSockets Server Sent Events WebSockets \u00b6 Subscriptions can be made over WebSockets implementing the Apollo GraphQL transport protocol using the /subscriptions endpoint. This seems to be the most widely used mechanism and is compatible with the majority of javascript front libraries. The implementation of the JavaScript WebSocket client is too complex to describe here, but there is an implementation in @jetblack/graphql-client , the implementation of which is discussed here . This is the protocol used by the inbuilt GraphiQL IDE . Server Sent Events \u00b6 As well as the more popular WebSocket Subscription, a mechanism using server sent events is also supported. While this is uncommon, it is a really good use of SSE, as all the communication if from the server to the client. The GraphQL controller exposes an endpoint: /sse-subscription?query=...&variables=...&operationName=... This can be called in the following manner: const query = encodeURIComponent ( 'subscription { mySubscription { name timestamp } }' ) const url = `http://www.example.com/sse-subscription?query= ${ query } ` const eventSource = new EventSource ( url ) eventSource . onmessage = event => { data = JSON . parse ( event . data ) console . log ( data ) } We could wrap this up in the following manner: export function graphQLSubscriber ( url , query , variables , operationName , onError , onSuccess ) { let subscriptionUrl = url + '?query=' + encodeURIComponent ( query ) if ( variables ) { subscriptionUrl += '&variables=' + encodeURIComponent ( JSON . stringify ( variables )) } if ( operationName ) { subscriptionUrl += '&operationName=' + encodeURIComponent ( operationName ) } const eventSource = new EventSource ( subscriptionUrl ) eventSource . onmessage = event => onSuccess ( JSON . parse ( event . data )) eventSource . onerror = error => onError ( error ) // Return the close function to unsubscribe. return eventSource . close } This can then be called like this: const url = 'http://www.example.com/sse-subscription' const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null graphQLSubscriber ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data )) Queries, Mutations & Subscriptions \u00b6 In this implementation queries, mutations and subscriptions can all be made using the fetch api. With a successful query or mutation the response status code is 200 (OK), and the body contains the result. For a subscription the status code 201 (CREATED) is returned, and the location header contains the url to be used to request server sent events through the EventSource API. This means we can provide a single client function to handle all three requests. Here is some sample code that does this. export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onNext , onError , onComplete ) { const abortController = new AbortController () // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { onNext ( json ) onComplete () }) . catch ( error => onError ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { const data = JSON . parse ( event . data ) onNext ( data ) } eventSource . onerror = error => { onError ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) // Return an unsubscribe function. return () => { abortController . abort () } } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const unsubscribe = graphQLClient ( url , query , variables , operationName , data => console . log ( data ), error => console . log ( error ), () => console . log ( 'complete' )) // Later ... unsubscribe () Observable \u00b6 Clearly the above code roles it's own observable pattern. We can wrap this up with rxjs to provide a cleaner client. import { Observable } from 'rxjs' export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function observableGraphQL ( url , query , variables , operationName ) { return Observable . create ( observer => { const abortController = new AbortController () fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { observer . next ( json ) observer . complete () }) . catch ( error => observer . error ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { observer . next ( JSON . parse ( event . data )) } eventSource . onerror = error => { observer . error ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { observer . error ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => observer . error ( error )) // Return the unsubscribe function. return () => { abortController . abort () } }) } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const subscription = observableGraphQL ( url , query , variables , operationName ) . subscribe ({ next : responses => console . log ( response ), error : error => console . log ( error ), complete : () => console . log ( 'complete' ) }) // Later ... subscription . unsubscribe () Prebuilt Clients \u00b6 There are some prebuilt javascript clients: barejs-graphql-client for callback style clients. barejs-graphql-observable for observable style clients using rxjs .","title":"Clients"},{"location":"user-guide/clients/#clients","text":"","title":"Clients"},{"location":"user-guide/clients/#overview","text":"GraphQL supports three types of actions : Queries Mutations Subscriptions","title":"Overview"},{"location":"user-guide/clients/#queries-mutations","text":"The controller exposes an endpoint /graphql . There are a number of libraries that can be used including Facebook Relay and Apollo GraphQL . These are feature rich, but the underlying mechanism for queries and mutations is just a simple fetch request. Here is a code snippet demonstrating a query. const query = 'query { myQuery { someField otherField } }' const variables = null const operationName = null const url = 'http://www.exammple.com/graphql' // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => response . json ()) . then ( data => console . log ( data ) . catch ( error => console . log ( error )) We might wrap this up in the following function: export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onError , onSuccess ) { // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . ok ) { response . json () . then ( json => { onSuccess ( json ) }) . catch ( error => onError ( error )) } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) } This can then be called like this: const url = 'http://www.example.com/graphql' const query = 'query { someQuery { someField someOtherField } }' const variables = null const operationName = null graphQLClient ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data ))","title":"Queries &amp; Mutations"},{"location":"user-guide/clients/#subscriptions","text":"Two transport mechanisms are provided for GraphQL subscriptions: WebSockets Server Sent Events","title":"Subscriptions"},{"location":"user-guide/clients/#websockets","text":"Subscriptions can be made over WebSockets implementing the Apollo GraphQL transport protocol using the /subscriptions endpoint. This seems to be the most widely used mechanism and is compatible with the majority of javascript front libraries. The implementation of the JavaScript WebSocket client is too complex to describe here, but there is an implementation in @jetblack/graphql-client , the implementation of which is discussed here . This is the protocol used by the inbuilt GraphiQL IDE .","title":"WebSockets"},{"location":"user-guide/clients/#server-sent-events","text":"As well as the more popular WebSocket Subscription, a mechanism using server sent events is also supported. While this is uncommon, it is a really good use of SSE, as all the communication if from the server to the client. The GraphQL controller exposes an endpoint: /sse-subscription?query=...&variables=...&operationName=... This can be called in the following manner: const query = encodeURIComponent ( 'subscription { mySubscription { name timestamp } }' ) const url = `http://www.example.com/sse-subscription?query= ${ query } ` const eventSource = new EventSource ( url ) eventSource . onmessage = event => { data = JSON . parse ( event . data ) console . log ( data ) } We could wrap this up in the following manner: export function graphQLSubscriber ( url , query , variables , operationName , onError , onSuccess ) { let subscriptionUrl = url + '?query=' + encodeURIComponent ( query ) if ( variables ) { subscriptionUrl += '&variables=' + encodeURIComponent ( JSON . stringify ( variables )) } if ( operationName ) { subscriptionUrl += '&operationName=' + encodeURIComponent ( operationName ) } const eventSource = new EventSource ( subscriptionUrl ) eventSource . onmessage = event => onSuccess ( JSON . parse ( event . data )) eventSource . onerror = error => onError ( error ) // Return the close function to unsubscribe. return eventSource . close } This can then be called like this: const url = 'http://www.example.com/sse-subscription' const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null graphQLSubscriber ( url , query , variables , operationName , error => console . error ( error ), data => console . log ( data ))","title":"Server Sent Events"},{"location":"user-guide/clients/#queries-mutations-subscriptions","text":"In this implementation queries, mutations and subscriptions can all be made using the fetch api. With a successful query or mutation the response status code is 200 (OK), and the body contains the result. For a subscription the status code 201 (CREATED) is returned, and the location header contains the url to be used to request server sent events through the EventSource API. This means we can provide a single client function to handle all three requests. Here is some sample code that does this. export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function graphQLClient ( url , query , variables , operationName , onNext , onError , onComplete ) { const abortController = new AbortController () // Invoke fetch as a POST with the GraphQL content in the body. fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { onNext ( json ) onComplete () }) . catch ( error => onError ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { const data = JSON . parse ( event . data ) onNext ( data ) } eventSource . onerror = error => { onError ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { onError ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => onError ( error )) // Return an unsubscribe function. return () => { abortController . abort () } } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const unsubscribe = graphQLClient ( url , query , variables , operationName , data => console . log ( data ), error => console . log ( error ), () => console . log ( 'complete' )) // Later ... unsubscribe ()","title":"Queries, Mutations &amp; Subscriptions"},{"location":"user-guide/clients/#observable","text":"Clearly the above code roles it's own observable pattern. We can wrap this up with rxjs to provide a cleaner client. import { Observable } from 'rxjs' export class FetchError extends Error { constructor ( response , ... params ) { super (... params ) if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , FetchError ) } this . name = 'FetchError' this . response = response } } export function observableGraphQL ( url , query , variables , operationName ) { return Observable . create ( observer => { const abortController = new AbortController () fetch ( url , { method : 'POST' , signal : abortController . signal , body : JSON . stringify ({ query , variables , operationName }) }) . then ( response => { if ( response . status === 200 ) { // A 200 response is from a query or mutation. response . json () . then ( json => { observer . next ( json ) observer . complete () }) . catch ( error => observer . error ( error )) } else if ( response . status === 201 ) { // A 201 is the response for a subscription. // The url for the event source is passed in the 'location' header. const location = response . headers . get ( 'location' ) const eventSource = new EventSource ( location ) eventSource . onmessage = event => { observer . next ( JSON . parse ( event . data )) } eventSource . onerror = error => { observer . error ( error ) } abortController . signal . onabort = () => { if ( eventSource . readyState !== 2 ) { eventSource . close () } } } else { observer . error ( new FetchError ( response , 'Failed to execute GraphQL' )) } }) . catch ( error => observer . error ( error )) // Return the unsubscribe function. return () => { abortController . abort () } }) } This can then be called like this: const url = 'http://www.example.com/graphql' // This could be a query, mutation or subscription. const query = 'subscription { someSubscription { someField someOtherField } }' const variables = null const operationName = null const subscription = observableGraphQL ( url , query , variables , operationName ) . subscribe ({ next : responses => console . log ( response ), error : error => console . log ( error ), complete : () => console . log ( 'complete' ) }) // Later ... subscription . unsubscribe ()","title":"Observable"},{"location":"user-guide/clients/#prebuilt-clients","text":"There are some prebuilt javascript clients: barejs-graphql-client for callback style clients. barejs-graphql-observable for observable style clients using rxjs .","title":"Prebuilt Clients"},{"location":"user-guide/installation/","text":"Installation \u00b6 The package can be installed with pip. pip install bareasgi-graphql-next This is a Python 3.7 and later package with dependencies on: bareASGI graphql-core-next","title":"Installation"},{"location":"user-guide/installation/#installation","text":"The package can be installed with pip. pip install bareasgi-graphql-next This is a Python 3.7 and later package with dependencies on: bareASGI graphql-core-next","title":"Installation"},{"location":"user-guide/usage/","text":"Usage \u00b6 A utility function add_graphql_next is provided. from bareasgi import Application from bareasgi_graphql_next import add_graphql_next from star_wars.star_wars_schema import star_wars_schema import uvicorn app = Application () add_graphql_next ( app , star_wars_schema ) uvicorn . run ( app , port = 9009 )","title":"Usage"},{"location":"user-guide/usage/#usage","text":"A utility function add_graphql_next is provided. from bareasgi import Application from bareasgi_graphql_next import add_graphql_next from star_wars.star_wars_schema import star_wars_schema import uvicorn app = Application () add_graphql_next ( app , star_wars_schema ) uvicorn . run ( app , port = 9009 )","title":"Usage"}]}